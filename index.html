<!doctype html>
<html lang="en">
  <head>
    <!-- (Meta Tags and Head Content Remain the Same) -->
    <!-- Page Title -->
    <title>sudo-self.com</title>
    <style>
      body {
        margin: 0;
        background-color: #1a1a1a;
        color: white;
      }
      canvas {
        display: block;
      }
      .footer {
        position: fixed;
        left: 0;
        bottom: 0;
        width: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        text-align: center;
        padding: 10px;
        font-size: 1rem;
        font-family: Arial, sans-serif;
      }
      .footer a {
        color: white;
        text-decoration: none;
      }
      .footer a:hover {
        color: #8e8e8e;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>

    <script>
      let scene, camera, renderer, model, model2, currentModel;
      let controls, ambientLight, directionalLight;
      let gui, params;
      let shaderEnabled = false;
      let defaultMaterial, shaderMaterial;
      let hdrTexture;

      const vertexShader = `
      varying vec3 vColor;
      void main() {
        vColor = position.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
      const fragmentShader = `
      uniform vec3 color;
      varying vec3 vColor;
      void main() {
        gl_FragColor = vec4(vColor * color, 1.0);
      }
    `;

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        ambientLight = new THREE.AmbientLight(0x404040, 4);
        scene.add(ambientLight);
        directionalLight = new THREE.DirectionalLight(0xffffff, 5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        const hdrLoader = new THREE.RGBELoader();
        hdrLoader.load("./elmo.hdr", function (texture) {
          hdrTexture = texture;
          hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
          scene.environment = hdrTexture;

          const loader = new THREE.GLTFLoader();
          loader.load("/model.glb", (gltf) => {
            model = gltf.scene;
            currentModel = model; // Set current model
            scene.add(model);
            model.scale.set(1, 1, 1);

            defaultMaterial = model.children[0].material;

            shaderMaterial = new THREE.ShaderMaterial({
              uniforms: {
                color: { value: new THREE.Color(0xff0000) },
              },
              vertexShader: vertexShader,
              fragmentShader: fragmentShader,
            });

            toggleShader();
          });

          loader.load("/model2.glb", (gltf) => {
            model2 = gltf.scene;
            model2.visible = false; // Initially hidden
            scene.add(model2);
          });
        });

        camera.position.z = 3;

        gui = new dat.GUI();
        gui.close();
        params = {
          scale: 1,
          rotationX: 0,
          rotationY: 0,
          rotationZ: 0,
          positionX: 0,
          positionY: 0,
          positionZ: 0,
          lightIntensity: 1,
          lightColor: "#ffffff",
          shader: false,
          toggleModel: "model1", // Default to model1
        };

        gui.add(params, "toggleModel", ["model1", "model2"]).onChange(() => {
          toggleModel(params.toggleModel);
        });

        gui.add(params, "scale", 0.1, 5).onChange(() => {
          if (currentModel) currentModel.scale.set(params.scale, params.scale, params.scale);
        });

        gui.add(params, "rotationX", 0, Math.PI * 2).onChange(() => {
          if (currentModel) currentModel.rotation.x = params.rotationX;
        });

        gui.add(params, "rotationY", 0, Math.PI * 2).onChange(() => {
          if (currentModel) currentModel.rotation.y = params.rotationY;
        });

        gui.add(params, "rotationZ", 0, Math.PI * 2).onChange(() => {
          if (currentModel) currentModel.rotation.z = params.rotationZ;
        });

        gui.add(params, "positionX", -5, 5).onChange(() => {
          if (currentModel) currentModel.position.x = params.positionX;
        });

        gui.add(params, "positionY", -5, 5).onChange(() => {
          if (currentModel) currentModel.position.y = params.positionY;
        });

        gui.add(params, "positionZ", -5, 5).onChange(() => {
          if (currentModel) currentModel.position.z = params.positionZ;
        });

        gui.add(params, "lightIntensity", 0, 5).onChange(() => {
          if (ambientLight) ambientLight.intensity = params.lightIntensity;
          if (directionalLight)
            directionalLight.intensity = params.lightIntensity;
        });

        gui.addColor(params, "lightColor").onChange(() => {
          if (ambientLight) ambientLight.color.set(params.lightColor);
          if (directionalLight) directionalLight.color.set(params.lightColor);
        });

        gui.add(params, "shader").onChange(() => {
          shaderEnabled = params.shader;
          toggleShader();
        });

        const exportParams = () => {
          const data = JSON.stringify(params, null, 2);
          const blob = new Blob([data], { type: "application/json" });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = "model-params.json";
          link.click();
        };
        gui.add({ export: exportParams }, "export");

        animate();
      }

      function toggleShader() {
        if (shaderEnabled && currentModel) {
          currentModel.children[0].material = shaderMaterial;
        } else if (currentModel) {
          currentModel.children[0].material = defaultMaterial;
        }
      }

      function toggleModel(selectedModel) {
        if (selectedModel === "model1") {
          if (model) model.visible = true;
          if (model2) model2.visible = false;
          currentModel = model;
        } else {
          if (model) model.visible = false;
          if (model2) model2.visible = true;
          currentModel = model2;
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      init();
    </script>

    <div class="footer">
      <p><a href="https://sudo-self.com" target="_blank">sudo-self.com</a></p>
    </div>
  </body>
</html>









